{
  "language": "Solidity",
  "sources": {
    "contracts/lib/Checkpointing.sol": {
      "content": "pragma solidity ^0.5.17;\n\n\n/**\n* @title Checkpointing - Library to handle a historic set of numeric values\n*/\nlibrary Checkpointing {\n    uint256 private constant MAX_UINT192 = uint256(uint192(-1));\n\n    string private constant ERROR_VALUE_TOO_BIG = \"CHECKPOINT_VALUE_TOO_BIG\";\n    string private constant ERROR_CANNOT_ADD_PAST_VALUE = \"CHECKPOINT_CANNOT_ADD_PAST_VALUE\";\n\n    /**\n     * @dev To specify a value at a given point in time, we need to store two values:\n     *      - `time`: unit-time value to denote the first time when a value was registered\n     *      - `value`: a positive numeric value to registered at a given point in time\n     *\n     *      Note that `time` does not need to refer necessarily to a timestamp value, any time unit could be used\n     *      for it like block numbers, terms, etc.\n     */\n    struct Checkpoint {\n        uint64 time;\n        uint192 value;\n    }\n\n    /**\n     * @dev A history simply denotes a list of checkpoints\n     */\n    struct History {\n        Checkpoint[] history;\n    }\n\n    /**\n     * @dev Add a new value to a history for a given point in time. This function does not allow to add values previous\n     *      to the latest registered value, if the value willing to add corresponds to the latest registered value, it\n     *      will be updated.\n     * @param self Checkpoints history to be altered\n     * @param _time Point in time to register the given value\n     * @param _value Numeric value to be registered at the given point in time\n     */\n    function add(History storage self, uint64 _time, uint256 _value) internal {\n        require(_value <= MAX_UINT192, ERROR_VALUE_TOO_BIG);\n        _add192(self, _time, uint192(_value));\n    }\n\n    /**\n     * TODO\n     */\n    function lastUpdate(History storage self) internal view returns (uint256) {\n        uint256 length = self.history.length;\n\n        if (length > 0) {\n            return uint256(self.history[length - 1].time);\n        }\n\n        return 0;\n    }\n\n    /**\n     * @dev Fetch the latest registered value of history, it will return zero if there was no value registered\n     * @param self Checkpoints history to be queried\n     */\n    function getLast(History storage self) internal view returns (uint256) {\n        uint256 length = self.history.length;\n        if (length > 0) {\n            return uint256(self.history[length - 1].value);\n        }\n\n        return 0;\n    }\n\n    /**\n     * @dev Fetch the most recent registered past value of a history based on a given point in time that is not known\n     *      how recent it is beforehand. It will return zero if there is no registered value or if given time is\n     *      previous to the first registered value.\n     *      It uses a binary search.\n     * @param self Checkpoints history to be queried\n     * @param _time Point in time to query the most recent registered past value of\n     */\n    function get(History storage self, uint64 _time) internal view returns (uint256) {\n        return _binarySearch(self, _time);\n    }\n\n    /**\n     * @dev Private function to add a new value to a history for a given point in time. This function does not allow to\n     *      add values previous to the latest registered value, if the value willing to add corresponds to the latest\n     *      registered value, it will be updated.\n     * @param self Checkpoints history to be altered\n     * @param _time Point in time to register the given value\n     * @param _value Numeric value to be registered at the given point in time\n     */\n    function _add192(History storage self, uint64 _time, uint192 _value) private {\n        uint256 length = self.history.length;\n        if (length == 0) {\n            // If there was no value registered, we can insert it to the history directly.\n            self.history.push(Checkpoint(_time, _value));\n        } else {\n            Checkpoint storage currentCheckpoint = self.history[length - 1];\n            uint256 currentCheckpointTime = uint256(currentCheckpoint.time);\n\n            if (_time > currentCheckpointTime) {\n                // If the given point in time is after the latest registered value,\n                // we can insert it to the history directly.\n                self.history.push(Checkpoint(_time, _value));\n            } else if (_time == currentCheckpointTime) {\n                currentCheckpoint.value = _value;\n            } else { // ensure list ordering\n                // The given point cannot be before latest value, as past data cannot be changed\n                revert(ERROR_CANNOT_ADD_PAST_VALUE);\n            }\n        }\n    }\n\n    /**\n     * @dev Private function to execute a binary search to find the most recent registered past value of a history based on\n     *      a given point in time. It will return zero if there is no registered value or if given time is previous to\n     *      the first registered value. Note that this function will be more suitable when don't know how recent the\n     *      time used to index may be.\n     * @param self Checkpoints history to be queried\n     * @param _time Point in time to query the most recent registered past value of\n     */\n    function _binarySearch(History storage self, uint64 _time) private view returns (uint256) {\n        // If there was no value registered for the given history return simply zero\n        uint256 length = self.history.length;\n        if (length == 0) {\n            return 0;\n        }\n\n        // If the requested time is equal to or after the time of the latest registered value, return latest value\n        uint256 lastIndex = length - 1;\n        Checkpoint storage lastCheckpoint = self.history[lastIndex];\n        if (_time >= lastCheckpoint.time) {\n            return uint256(lastCheckpoint.value);\n        }\n\n        // If the requested time is previous to the first registered value, return zero to denote missing checkpoint\n        if (length == 1 || _time < self.history[0].time) {\n            return 0;\n        }\n\n        // Execute a binary search between the checkpointed times of the history\n        uint256 low = 0;\n        uint256 high = lastIndex - 1;\n\n        while (high > low) {\n            // No need for SafeMath: for this to overflow array size should be ~2^255\n            uint256 mid = (high + low + 1) / 2;\n            Checkpoint storage checkpoint = self.history[mid];\n            uint64 midTime = checkpoint.time;\n\n            if (_time > midTime) {\n                low = mid;\n            } else if (_time < midTime) {\n                // No need for SafeMath: high > low >= 0 => high >= 1 => mid >= 1\n                high = mid - 1;\n            } else {\n                return uint256(checkpoint.value);\n            }\n        }\n\n        return uint256(self.history[low].value);\n    }\n}\n"
    },
    "contracts/lib/os/IsContract.sol": {
      "content": "// Brought from https://github.com/aragon/aragonOS/blob/v4.3.0/contracts/common/IsContract.sol\n// Adapted to use pragma ^0.5.8 and satisfy our linter rules\n\npragma solidity ^0.5.8;\n\n\ncontract IsContract {\n    /*\n    * NOTE: this should NEVER be used for authentication\n    * (see pitfalls: https://github.com/fergarrui/ethereum-security/tree/master/contracts/extcodesize).\n    *\n    * This is only intended to be used as a sanity check that an address is actually a contract,\n    * RATHER THAN an address not being a contract.\n    */\n    function isContract(address _target) internal view returns (bool) {\n        if (_target == address(0)) {\n            return false;\n        }\n\n        uint256 size;\n        assembly { size := extcodesize(_target) }\n        return size > 0;\n    }\n}\n"
    },
    "contracts/lib/os/SafeERC20.sol": {
      "content": "// Brought from https://github.com/aragon/aragonOS/blob/v4.3.0/contracts/common/SafeERC20.sol\n// Adapted to use pragma ^0.5.8 and satisfy our linter rules\n\npragma solidity ^0.5.8;\n\nimport \"../../standards/IERC20.sol\";\n\n\nlibrary SafeERC20 {\n    // Before 0.5, solidity has a mismatch between `address.transfer()` and `token.transfer()`:\n    // https://github.com/ethereum/solidity/issues/3544\n    bytes4 private constant TRANSFER_SELECTOR = 0xa9059cbb;\n\n    /**\n    * @dev Same as a standards-compliant ERC20.transfer() that never reverts (returns false).\n    *      Note that this makes an external call to the token.\n    */\n    function safeTransfer(IERC20 _token, address _to, uint256 _amount) internal returns (bool) {\n        bytes memory transferCallData = abi.encodeWithSelector(\n            TRANSFER_SELECTOR,\n            _to,\n            _amount\n        );\n        return invokeAndCheckSuccess(address(_token), transferCallData);\n    }\n\n    /**\n    * @dev Same as a standards-compliant ERC20.transferFrom() that never reverts (returns false).\n    *      Note that this makes an external call to the token.\n    */\n    function safeTransferFrom(IERC20 _token, address _from, address _to, uint256 _amount) internal returns (bool) {\n        bytes memory transferFromCallData = abi.encodeWithSelector(\n            _token.transferFrom.selector,\n            _from,\n            _to,\n            _amount\n        );\n        return invokeAndCheckSuccess(address(_token), transferFromCallData);\n    }\n\n    /**\n    * @dev Same as a standards-compliant ERC20.approve() that never reverts (returns false).\n    *      Note that this makes an external call to the token.\n    */\n    function safeApprove(IERC20 _token, address _spender, uint256 _amount) internal returns (bool) {\n        bytes memory approveCallData = abi.encodeWithSelector(\n            _token.approve.selector,\n            _spender,\n            _amount\n        );\n        return invokeAndCheckSuccess(address(_token), approveCallData);\n    }\n\n    function invokeAndCheckSuccess(address _addr, bytes memory _calldata) private returns (bool) {\n        bool ret;\n        assembly {\n            let ptr := mload(0x40)    // free memory pointer\n\n            let success := call(\n                gas,                  // forward all gas\n                _addr,                // address\n                0,                    // no value\n                add(_calldata, 0x20), // calldata start\n                mload(_calldata),     // calldata length\n                ptr,                  // write output over free memory\n                0x20                  // uint256 return\n            )\n\n            if gt(success, 0) {\n            // Check number of bytes returned from last function call\n                switch returndatasize\n\n                // No bytes returned: assume success\n                case 0 {\n                    ret := 1\n                }\n\n                // 32 bytes returned: check if non-zero\n                case 0x20 {\n                // Only return success if returned data was true\n                // Already have output in ptr\n                    ret := eq(mload(ptr), 1)\n                }\n\n                // Not sure what was returned: don't mark as success\n                default { }\n            }\n        }\n        return ret;\n    }\n}\n"
    },
    "contracts/lib/os/SafeMath.sol": {
      "content": "// Brought from https://github.com/aragon/aragonOS/blob/v4.3.0/contracts/lib/math/SafeMath.sol\n// Adapted to use pragma ^0.5.8 and satisfy our linter rules\n\npragma solidity >=0.4.24 <0.6.0;\n\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n    string private constant ERROR_ADD_OVERFLOW = \"MATH_ADD_OVERFLOW\";\n    string private constant ERROR_SUB_UNDERFLOW = \"MATH_SUB_UNDERFLOW\";\n    string private constant ERROR_MUL_OVERFLOW = \"MATH_MUL_OVERFLOW\";\n    string private constant ERROR_DIV_ZERO = \"MATH_DIV_ZERO\";\n\n    /**\n    * @dev Multiplies two numbers, reverts on overflow.\n    */\n    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (_a == 0) {\n            return 0;\n        }\n\n        uint256 c = _a * _b;\n        require(c / _a == _b, ERROR_MUL_OVERFLOW);\n\n        return c;\n    }\n\n    /**\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n    */\n    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        require(_b > 0, ERROR_DIV_ZERO); // Solidity only automatically asserts when dividing by 0\n        uint256 c = _a / _b;\n        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        require(_b <= _a, ERROR_SUB_UNDERFLOW);\n        uint256 c = _a - _b;\n\n        return c;\n    }\n\n    /**\n    * @dev Adds two numbers, reverts on overflow.\n    */\n    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        uint256 c = _a + _b;\n        require(c >= _a, ERROR_ADD_OVERFLOW);\n\n        return c;\n    }\n\n    /**\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n    * reverts when dividing by zero.\n    */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, ERROR_DIV_ZERO);\n        return a % b;\n    }\n}\n"
    },
    "contracts/lib/os/SafeMath64.sol": {
      "content": "// Brought from https://github.com/aragon/aragonOS/blob/v4.3.0/contracts/lib/math/SafeMath64.sol\n// Adapted to use pragma ^0.5.8 and satisfy our linter rules\n\npragma solidity ^0.5.8;\n\n\n/**\n * @title SafeMath64\n * @dev Math operations for uint64 with safety checks that revert on error\n */\nlibrary SafeMath64 {\n    string private constant ERROR_ADD_OVERFLOW = \"MATH64_ADD_OVERFLOW\";\n    string private constant ERROR_SUB_UNDERFLOW = \"MATH64_SUB_UNDERFLOW\";\n    string private constant ERROR_MUL_OVERFLOW = \"MATH64_MUL_OVERFLOW\";\n    string private constant ERROR_DIV_ZERO = \"MATH64_DIV_ZERO\";\n\n    /**\n    * @dev Multiplies two numbers, reverts on overflow.\n    */\n    function mul(uint64 _a, uint64 _b) internal pure returns (uint64) {\n        uint256 c = uint256(_a) * uint256(_b);\n        require(c < 0x010000000000000000, ERROR_MUL_OVERFLOW); // 2**64 (less gas this way)\n\n        return uint64(c);\n    }\n\n    /**\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n    */\n    function div(uint64 _a, uint64 _b) internal pure returns (uint64) {\n        require(_b > 0, ERROR_DIV_ZERO); // Solidity only automatically asserts when dividing by 0\n        uint64 c = _a / _b;\n        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function sub(uint64 _a, uint64 _b) internal pure returns (uint64) {\n        require(_b <= _a, ERROR_SUB_UNDERFLOW);\n        uint64 c = _a - _b;\n\n        return c;\n    }\n\n    /**\n    * @dev Adds two numbers, reverts on overflow.\n    */\n    function add(uint64 _a, uint64 _b) internal pure returns (uint64) {\n        uint64 c = _a + _b;\n        require(c >= _a, ERROR_ADD_OVERFLOW);\n\n        return c;\n    }\n\n    /**\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n    * reverts when dividing by zero.\n    */\n    function mod(uint64 a, uint64 b) internal pure returns (uint64) {\n        require(b != 0, ERROR_DIV_ZERO);\n        return a % b;\n    }\n}\n"
    },
    "contracts/lib/os/TimeHelpers.sol": {
      "content": "// Brought from https://github.com/aragon/aragonOS/blob/v4.3.0/contracts/common/TimeHelpers.sol\n// Adapted to use pragma ^0.5.8 and satisfy our linter rules\n\npragma solidity ^0.5.8;\n\nimport \"./Uint256Helpers.sol\";\n\n\ncontract TimeHelpers {\n    using Uint256Helpers for uint256;\n\n    /**\n    * @dev Returns the current block number.\n    *      Using a function rather than `block.number` allows us to easily mock the block number in\n    *      tests.\n    */\n    function getBlockNumber() internal view returns (uint256) {\n        return block.number;\n    }\n\n    /**\n    * @dev Returns the current block number, converted to uint64.\n    *      Using a function rather than `block.number` allows us to easily mock the block number in\n    *      tests.\n    */\n    function getBlockNumber64() internal view returns (uint64) {\n        return getBlockNumber().toUint64();\n    }\n\n    /**\n    * @dev Returns the current timestamp.\n    *      Using a function rather than `block.timestamp` allows us to easily mock it in\n    *      tests.\n    */\n    function getTimestamp() internal view returns (uint256) {\n        return block.timestamp; // solium-disable-line security/no-block-members\n    }\n\n    /**\n    * @dev Returns the current timestamp, converted to uint64.\n    *      Using a function rather than `block.timestamp` allows us to easily mock it in\n    *      tests.\n    */\n    function getTimestamp64() internal view returns (uint64) {\n        return getTimestamp().toUint64();\n    }\n}\n"
    },
    "contracts/lib/os/Uint256Helpers.sol": {
      "content": "// Brought from https://github.com/aragon/aragonOS/blob/v4.3.0/contracts/common/Uint256Helpers.sol\n// Adapted to use pragma ^0.5.8 and satisfy our linter rules\n\npragma solidity ^0.5.8;\n\n\nlibrary Uint256Helpers {\n    uint256 private constant MAX_UINT8 = uint8(-1);\n    uint256 private constant MAX_UINT64 = uint64(-1);\n\n    string private constant ERROR_UINT8_NUMBER_TOO_BIG = \"UINT8_NUMBER_TOO_BIG\";\n    string private constant ERROR_UINT64_NUMBER_TOO_BIG = \"UINT64_NUMBER_TOO_BIG\";\n\n    function toUint8(uint256 a) internal pure returns (uint8) {\n        require(a <= MAX_UINT8, ERROR_UINT8_NUMBER_TOO_BIG);\n        return uint8(a);\n    }\n\n    function toUint64(uint256 a) internal pure returns (uint64) {\n        require(a <= MAX_UINT64, ERROR_UINT64_NUMBER_TOO_BIG);\n        return uint64(a);\n    }\n}\n"
    },
    "contracts/locking/ILockable.sol": {
      "content": "pragma solidity ^0.5.17;\n\n\ninterface ILockable {\n    event NewLockManager(address indexed user, address indexed lockManager, bytes data);\n    event LockAmountChanged(address indexed user, address indexed lockManager, uint256 amount);\n    event LockAllowanceChanged(address indexed user, address indexed lockManager, uint256 allowance);\n    event LockManagerRemoved(address indexed user, address indexed lockManager);\n    event LockManagerTransferred(address indexed user, address indexed oldLockManager, address indexed newLockManager);\n\n    function allowManager(address _lockManager, uint256 _allowance, bytes calldata _data) external;\n    function unlockAndRemoveManager(address _user, address _lockManager) external;\n    function increaseLockAllowance(address _lockManager, uint256 _allowance) external;\n    function decreaseLockAllowance(address _user, address _lockManager, uint256 _allowance) external;\n\n    function lock(address _user, uint256 _amount) external;\n    function unlock(address _user, address _lockManager, uint256 _amount) external;\n    function slash(address _user, address _to, uint256 _amount) external;\n    function slashAndUnstake(address _user, address _to, uint256 _amount) external;\n\n    function getLock(address _user, address _lockManager) external view returns (uint256 _amount, uint256 _allowance);\n    function unlockedBalanceOf(address _user) external view returns (uint256);\n    function lockedBalanceOf(address _user) external view returns (uint256);\n    function getBalancesOf(address _user) external view returns (uint256 staked, uint256 locked);\n    function canUnlock(address _sender, address _user, address _lockManager, uint256 _amount) external view returns (bool);\n}\n"
    },
    "contracts/locking/ILockManager.sol": {
      "content": "pragma solidity ^0.5.17;\n\n\ninterface ILockManager {\n    /**\n     * @notice Check if `_user`'s lock by `_lockManager` can be unlocked\n     * @param _user Owner of lock\n     * @param _amount Amount of locked tokens to unlock\n     * @return Whether given user's lock can be unlocked\n     */\n    function canUnlock(address _user, uint256 _amount) external view returns (bool);\n}\n"
    },
    "contracts/Staking.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport \"./lib/Checkpointing.sol\";\nimport \"./lib/os/IsContract.sol\";\nimport \"./lib/os/SafeMath.sol\";\nimport \"./lib/os/SafeERC20.sol\";\nimport \"./lib/os/TimeHelpers.sol\";\n\nimport \"./locking/ILockable.sol\";\nimport \"./locking/ILockManager.sol\";\n\nimport \"./standards/IERC900.sol\";\nimport \"./standards/IERC900History.sol\";\nimport \"./standards/IApproveAndCallFallBack.sol\";\n\n\ncontract Staking is IERC900, IERC900History, ILockable, IApproveAndCallFallBack, IsContract, TimeHelpers {\n    using Checkpointing for Checkpointing.History;\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    uint256 private constant MAX_UINT64 = uint256(uint64(-1));\n\n    string private constant ERROR_TOKEN_NOT_CONTRACT = \"STAKING_TOKEN_NOT_CONTRACT\";\n    string private constant ERROR_AMOUNT_ZERO = \"STAKING_AMOUNT_ZERO\";\n    string private constant ERROR_TOKEN_TRANSFER = \"STAKING_TOKEN_TRANSFER_FAIL\";\n    string private constant ERROR_TOKEN_DEPOSIT = \"STAKING_TOKEN_DEPOSIT_FAIL\";\n    string private constant ERROR_WRONG_TOKEN = \"STAKING_WRONG_TOKEN\";\n    string private constant ERROR_NOT_ENOUGH_BALANCE = \"STAKING_NOT_ENOUGH_BALANCE\";\n    string private constant ERROR_NOT_ENOUGH_ALLOWANCE = \"STAKING_NOT_ENOUGH_ALLOWANCE\";\n    string private constant ERROR_ALLOWANCE_ZERO = \"STAKING_ALLOWANCE_ZERO\";\n    string private constant ERROR_LOCK_ALREADY_EXISTS = \"STAKING_LOCK_ALREADY_EXISTS\";\n    string private constant ERROR_LOCK_DOES_NOT_EXIST = \"STAKING_LOCK_DOES_NOT_EXIST\";\n    string private constant ERROR_NOT_ENOUGH_LOCK = \"STAKING_NOT_ENOUGH_LOCK\";\n    string private constant ERROR_CANNOT_UNLOCK = \"STAKING_CANNOT_UNLOCK\";\n    string private constant ERROR_CANNOT_CHANGE_ALLOWANCE = \"STAKING_CANNOT_CHANGE_ALLOWANCE\";\n    string private constant ERROR_BLOCKNUMBER_TOO_BIG = \"STAKING_BLOCKNUMBER_TOO_BIG\";\n\n    event StakeTransferred(address indexed from, address indexed to, uint256 amount);\n\n    struct Lock {\n        uint256 amount;\n        uint256 allowance; // A lock is considered active when its allowance is greater than zero, and the allowance is always greater than or equal to amount\n    }\n\n    struct Account {\n        mapping (address => Lock) locks; // Mapping of lock manager => lock info\n        uint256 totalLocked;\n        Checkpointing.History stakedHistory;\n    }\n\n    IERC20 public token;\n    mapping (address => Account) internal accounts;\n    Checkpointing.History internal totalStakedHistory;\n\n    /**\n     * @notice Initialize Staking app with token `_token`\n     * @param _token ERC20 token used for staking\n     */\n    constructor(IERC20 _token) public {\n        require(isContract(address(_token)), ERROR_TOKEN_NOT_CONTRACT);\n        token = _token;\n    }\n\n    /**\n     * @notice Stake `@tokenAmount(self.token(): address, _amount)`\n     * @dev Callable only by a user\n     * @param _amount Amount of tokens to be staked\n     * @param _data Optional data emitted with the Staked event, to add signalling information in more complex staking applications\n     */\n    function stake(uint256 _amount, bytes calldata _data) external {\n        _stakeFor(msg.sender, msg.sender, _amount, _data);\n    }\n\n    /**\n     * @notice Stake `@tokenAmount(self.token(): address, _amount)` for `_user`\n     * @dev Callable only by a user\n     * @param _user Address to stake tokens to\n     * @param _amount Amount of tokens to be staked\n     * @param _data Optional data emitted with the Staked event, to add signalling information in more complex staking applications\n     */\n    function stakeFor(address _user, uint256 _amount, bytes calldata _data) external {\n        _stakeFor(msg.sender, _user, _amount, _data);\n    }\n\n    /**\n     * @notice Unstake `@tokenAmount(self.token(): address, _amount)`\n     * @dev Callable only by a user\n     * @param _amount Amount of tokens to be unstaked\n     * @param _data Optional data emitted with the Unstaked event, to add signalling information in more complex staking applications\n     */\n    function unstake(uint256 _amount, bytes calldata _data) external {\n        // _unstake() expects the caller to do this check\n        require(_amount > 0, ERROR_AMOUNT_ZERO);\n\n        _unstake(msg.sender, _amount, _data);\n    }\n\n    /**\n     * @notice Allow `_lockManager` to lock up to `@tokenAmount(self.token(): address, _allowance)` of your staked balance\n     * @dev Callable only by a user.\n     *      This creates a new lock, so this manager cannot have an existing lock in place for the caller.\n     * @param _lockManager Lock manager\n     * @param _allowance Amount of tokens the manager will be allowed to lock\n     * @param _data Optional, arbitrary data to be submitted to the manager\n     */\n    function allowManager(address _lockManager, uint256 _allowance, bytes calldata _data) external {\n        _allowManager(_lockManager, _allowance, _data);\n    }\n\n    /**\n     * @notice Increase allowance of lock manager `_lockManager` by `@tokenAmount(self.token(): address, _allowance)`\n     * @dev Callable only by a user\n     * @param _lockManager Lock manager\n     * @param _allowance Amount to increase allowance by\n     */\n    function increaseLockAllowance(address _lockManager, uint256 _allowance) external {\n        Lock storage lock_ = accounts[msg.sender].locks[_lockManager];\n        require(lock_.allowance > 0, ERROR_LOCK_DOES_NOT_EXIST);\n\n        _increaseLockAllowance(_lockManager, lock_, _allowance);\n    }\n\n    /**\n     * @notice Decrease allowance of lock manager `_lockManager` by `@tokenAmount(self.token(): address, _allowance)`\n     * @dev Callable only by the user or lock manager.\n     *      Cannot completely remove the allowance to the lock manager (and deactivate the lock).\n     * @param _user Owner of the locked tokens\n     * @param _lockManager Lock manager\n     * @param _allowance Amount to decrease allowance by\n     */\n    function decreaseLockAllowance(address _user, address _lockManager, uint256 _allowance) external {\n        require(msg.sender == _user || msg.sender == _lockManager, ERROR_CANNOT_CHANGE_ALLOWANCE);\n        require(_allowance > 0, ERROR_AMOUNT_ZERO);\n\n        Lock storage lock_ = accounts[_user].locks[_lockManager];\n        uint256 newAllowance = lock_.allowance.sub(_allowance);\n        require(newAllowance >= lock_.amount, ERROR_NOT_ENOUGH_ALLOWANCE);\n        // unlockAndRemoveManager() must be used for this:\n        require(newAllowance > 0, ERROR_ALLOWANCE_ZERO);\n\n        lock_.allowance = newAllowance;\n\n        emit LockAllowanceChanged(_user, _lockManager, newAllowance);\n    }\n\n    /**\n     * @notice Lock `@tokenAmount(self.token(): address, _amount)` to lock manager `msg.sender`\n     * @dev Callable only by an allowed lock manager\n     * @param _user Owner of the locked tokens\n     * @param _amount Amount of tokens to lock\n     */\n    function lock(address _user, uint256 _amount) external {\n        require(_amount > 0, ERROR_AMOUNT_ZERO);\n\n        // check enough unlocked tokens are available\n        require(_amount <= _unlockedBalanceOf(_user), ERROR_NOT_ENOUGH_BALANCE);\n\n        Account storage account = accounts[_user];\n        Lock storage lock_ = account.locks[msg.sender];\n\n        uint256 newAmount = lock_.amount.add(_amount);\n        // check allowance is enough, it also means that lock exists, as newAmount is greater than zero\n        require(newAmount <= lock_.allowance, ERROR_NOT_ENOUGH_ALLOWANCE);\n\n        lock_.amount = newAmount;\n\n        // update total\n        account.totalLocked = account.totalLocked.add(_amount);\n\n        emit LockAmountChanged(_user, msg.sender, newAmount);\n    }\n\n    /**\n     * @notice Unlock `@tokenAmount(self.token(): address, _amount)` from lock manager `_lockManager`\n     * @dev Callable only by the user or lock manager. If called by the user, checks with the lock manager whether the request should be allowed.\n     * @param _user Owner of the locked tokens\n     * @param _lockManager Lock manager\n     * @param _amount Amount of tokens to unlock\n     */\n    function unlock(address _user, address _lockManager, uint256 _amount) external {\n        // _unlockUnsafe() expects the caller to do this check\n        require(_amount > 0, ERROR_AMOUNT_ZERO);\n\n        require(_canUnlockUnsafe(msg.sender, _user, _lockManager, _amount), ERROR_CANNOT_UNLOCK);\n\n        _unlockUnsafe(_user, _lockManager, _amount);\n    }\n\n    /**\n     * @notice Unlock all tokens from lock manager `_lockManager` and remove them as a manager\n     * @dev Callable only by the user or lock manager. If called by the user, checks with the lock manager whether the request should be allowed.\n     * @param _user Owner of the locked tokens\n     * @param _lockManager Lock manager\n     */\n    function unlockAndRemoveManager(address _user, address _lockManager) external {\n        require(_canUnlockUnsafe(msg.sender, _user, _lockManager, 0), ERROR_CANNOT_UNLOCK);\n\n        Account storage account = accounts[_user];\n        Lock storage lock_ = account.locks[_lockManager];\n\n        uint256 amount = lock_.amount;\n        // update total\n        account.totalLocked = account.totalLocked.sub(amount);\n\n        emit LockAmountChanged(_user, _lockManager, 0);\n        emit LockManagerRemoved(_user, _lockManager);\n\n        delete account.locks[_lockManager];\n    }\n\n    /**\n     * @notice Slash `@tokenAmount(self.token(): address, _amount)` from `_from`'s locked balance to `_to`'s staked balance\n     * @dev Callable only by a lock manager\n     * @param _from Owner of the locked tokens\n     * @param _to Recipient\n     * @param _amount Amount of tokens to be transferred via slashing\n     */\n    function slash(address _from, address _to, uint256 _amount) external {\n        _unlockUnsafe(_from, msg.sender, _amount);\n        _transfer(_from, _to, _amount);\n    }\n\n    /**\n     * @notice Slash `@tokenAmount(self.token(): address, _amount)` from `_from`'s locked balance  directly to `_to`'s balance\n     * @dev Callable only by a lock manager\n     * @param _from Owner of the locked tokens\n     * @param _to Recipient\n     * @param _amount Amount of tokens to be transferred via slashing\n     */\n    function slashAndUnstake(address _from, address _to, uint256 _amount) external {\n        _unlockUnsafe(_from, msg.sender, _amount);\n        _transferAndUnstake(_from, _to, _amount);\n    }\n\n    /**\n     * @notice Slash `@tokenAmount(self.token(): address, _slashAmount)` from `_from`'s locked balance to `_to`'s staked balance, and leave an additional `@tokenAmount(self.token(): address, _unlockAmount)` unlocked for `_from`\n     * @dev Callable only by a lock manager\n     * @param _from Owner of the locked tokens\n     * @param _to Recipient\n     * @param _unlockAmount Amount of tokens to be left unlocked\n     * @param _slashAmount Amount of tokens to be transferred via slashing\n     */\n    function slashAndUnlock(\n        address _from,\n        address _to,\n        uint256 _unlockAmount,\n        uint256 _slashAmount\n    )\n        external\n    {\n        _unlockUnsafe(_from, msg.sender, _unlockAmount.add(_slashAmount));\n        _transfer(_from, _to, _slashAmount);\n    }\n\n    /**\n     * @notice Transfer `@tokenAmount(self.token(): address, _amount)` to `_to`’s staked balance\n     * @dev Callable only by a user\n     * @param _to Recipient\n     * @param _amount Amount of tokens to be transferred\n     */\n    function transfer(address _to, uint256 _amount) external {\n        _transfer(msg.sender, _to, _amount);\n    }\n\n    /**\n     * @notice Transfer `@tokenAmount(self.token(): address, _amount)` directly to `_to`’s balance\n     * @dev Callable only by a user\n     * @param _to Recipient\n     * @param _amount Amount of tokens to be transferred\n     */\n    function transferAndUnstake(address _to, uint256 _amount) external {\n        _transferAndUnstake(msg.sender, _to, _amount);\n    }\n\n    /**\n    /**\n     * @dev ApproveAndCallFallBack compliance.\n     *      Stakes the approved tokens for the user, allowing users to stake their tokens in a single transaction.\n     *      Callable only by the staking token.\n     * @param _from Account approving tokens\n     * @param _amount Amount of tokens being approved\n     * @param _token Token being approved, should be the caller\n     * @param _data Optional data emitted with the Staked event, to add signalling information in more complex staking applications\n     */\n    function receiveApproval(address _from, uint256 _amount, address _token, bytes calldata _data) external {\n        require(_token == msg.sender && _token == address(token), ERROR_WRONG_TOKEN);\n\n        _stakeFor(_from, _from, _amount, _data);\n    }\n\n    /**\n     * @dev Tell whether the history methods are supported\n     * @return Always true\n     */\n    function supportsHistory() external pure returns (bool) {\n        return true;\n    }\n\n    /**\n     * @dev Tell the last time `_user` modified their staked balance\n     * @param _user Address\n     * @return Last block number the account's staked balance was modified. 0 if it has never been modified.\n     */\n    function lastStakedFor(address _user) external view returns (uint256) {\n        return accounts[_user].stakedHistory.lastUpdate();\n    }\n\n    /**\n     * @dev Tell the current locked balance for `_user`\n     * @param _user Address\n     * @return Amount of locked tokens owned by the requested account across all locks\n     */\n    function lockedBalanceOf(address _user) external view returns (uint256) {\n        return _lockedBalanceOf(_user);\n    }\n\n    /**\n     * @dev Tell details of `_user`'s lock managed by `_lockManager`\n     * @param _user Address\n     * @param _lockManager Lock manager\n     * @return Amount of locked tokens\n     * @return Amount of tokens that lock manager is allowed to lock\n     */\n    function getLock(address _user, address _lockManager)\n        external\n        view\n        returns (\n            uint256 amount,\n            uint256 allowance\n        )\n    {\n        Lock storage lock_ = accounts[_user].locks[_lockManager];\n        amount = lock_.amount;\n        allowance = lock_.allowance;\n    }\n\n    /**\n     * @dev Tell the current staked and locked balances for `_user`\n     * @param _user Address\n     * @return Staked balance\n     * @return Locked balance\n     */\n    function getBalancesOf(address _user) external view returns (uint256 staked, uint256 locked) {\n        staked = _totalStakedFor(_user);\n        locked = _lockedBalanceOf(_user);\n    }\n\n    /**\n     * @dev Tell the current staked balance for `_user`\n     * @param _user Address\n     * @return Staked balance\n     */\n    function totalStakedFor(address _user) external view returns (uint256) {\n        return _totalStakedFor(_user);\n    }\n\n    /**\n     * @dev Tell the total staked balance from all users\n     * @return The total amount of staked tokens from all users\n     */\n    function totalStaked() external view returns (uint256) {\n        return _totalStaked();\n    }\n\n    /**\n     * @dev Tell the staked balance for `_user` at block number `_blockNumber`\n     * @param _user Address\n     * @param _blockNumber Block height\n     * @return Staked balance at the given block number\n     */\n    function totalStakedForAt(address _user, uint256 _blockNumber) external view returns (uint256) {\n        require(_blockNumber <= MAX_UINT64, ERROR_BLOCKNUMBER_TOO_BIG);\n\n        return accounts[_user].stakedHistory.get(uint64(_blockNumber));\n    }\n\n    /**\n     * @dev Tell the total staked balance from all users at block number `_blockNumber`\n     * @param _blockNumber Block height\n     * @return The total amount of staked tokens from all users at the given block number\n     */\n    function totalStakedAt(uint256 _blockNumber) external view returns (uint256) {\n        require(_blockNumber <= MAX_UINT64, ERROR_BLOCKNUMBER_TOO_BIG);\n\n        return totalStakedHistory.get(uint64(_blockNumber));\n    }\n\n    /**\n     * @dev Tell the portion of `user`'s staked balance that can be immediately withdrawn\n     * @param _user Address\n     * @return Amount of tokens available to be withdrawn\n     */\n    function unlockedBalanceOf(address _user) external view returns (uint256) {\n        return _unlockedBalanceOf(_user);\n    }\n\n    /**\n     * @dev Check if `_sender` can unlock `@tokenAmount(self.token(): address, _amount)` from `_user`'s lock managed by `_lockManager`\n     * @param _sender Address that would try to unlock tokens\n     * @param _user Owner of lock\n     * @param _lockManager Lock manager\n     * @param _amount Amount of locked tokens to unlock. If zero, the full locked amount.\n     * @return Whether sender is allowed to unlock tokens from the given lock\n     */\n    function canUnlock(address _sender, address _user, address _lockManager, uint256 _amount) external view returns (bool) {\n        return _canUnlockUnsafe(_sender, _user, _lockManager, _amount);\n    }\n\n    function _stakeFor(address _from, address _user, uint256 _amount, bytes memory _data) internal {\n        // staking 0 tokens is invalid\n        require(_amount > 0, ERROR_AMOUNT_ZERO);\n\n        // checkpoint updated staking balance\n        uint256 newStake = _modifyStakeBalance(_user, _amount, true);\n\n        // checkpoint total supply\n        _modifyTotalStaked(_amount, true);\n\n        // pull tokens into Staking contract\n        require(token.safeTransferFrom(_from, address(this), _amount), ERROR_TOKEN_DEPOSIT);\n\n        emit Staked(_user, _amount, newStake, _data);\n    }\n\n    /**\n     * @dev Assumes the caller has already checked _amount > 0\n     */\n    function _unstake(address _from, uint256 _amount, bytes memory _data) internal {\n        // checkpoint updated staking balance\n        uint256 newStake = _modifyStakeBalance(_from, _amount, false);\n\n        // checkpoint total supply\n        _modifyTotalStaked(_amount, false);\n\n        // transfer tokens\n        require(token.safeTransfer(_from, _amount), ERROR_TOKEN_TRANSFER);\n\n        emit Unstaked(_from, _amount, newStake, _data);\n    }\n\n    function _modifyStakeBalance(address _user, uint256 _by, bool _increase) internal returns (uint256) {\n        uint256 currentStake = _totalStakedFor(_user);\n\n        uint256 newStake;\n        if (_increase) {\n            newStake = currentStake.add(_by);\n        } else {\n            require(_by <= _unlockedBalanceOf(_user), ERROR_NOT_ENOUGH_BALANCE);\n            newStake = currentStake.sub(_by);\n        }\n\n        // add new value to account history\n        accounts[_user].stakedHistory.add(getBlockNumber64(), newStake);\n\n        return newStake;\n    }\n\n    function _modifyTotalStaked(uint256 _by, bool _increase) internal {\n        uint256 currentStake = _totalStaked();\n\n        uint256 newStake;\n        if (_increase) {\n            newStake = currentStake.add(_by);\n        } else {\n            newStake = currentStake.sub(_by);\n        }\n\n        // add new value to total history\n        totalStakedHistory.add(getBlockNumber64(), newStake);\n    }\n\n    function _allowManager(address _lockManager, uint256 _allowance, bytes memory _data) internal {\n        Lock storage lock_ = accounts[msg.sender].locks[_lockManager];\n        // ensure lock doesn't exist yet\n        require(lock_.allowance == 0, ERROR_LOCK_ALREADY_EXISTS);\n\n        emit NewLockManager(msg.sender, _lockManager, _data);\n\n        _increaseLockAllowance(_lockManager, lock_, _allowance);\n    }\n\n    function _increaseLockAllowance(address _lockManager, Lock storage _lock, uint256 _allowance) internal {\n        require(_allowance > 0, ERROR_AMOUNT_ZERO);\n\n        uint256 newAllowance = _lock.allowance.add(_allowance);\n        _lock.allowance = newAllowance;\n\n        emit LockAllowanceChanged(msg.sender, _lockManager, newAllowance);\n    }\n\n    /**\n     * @dev Assumes `canUnlock` passes, i.e., either sender is the lock manager or it’s the owner,\n     *      and the lock manager allows to unlock.\n     */\n    function _unlockUnsafe(address _user, address _lockManager, uint256 _amount) internal {\n        Account storage account = accounts[_user];\n        Lock storage lock_ = account.locks[_lockManager];\n\n        uint256 lockAmount = lock_.amount;\n        require(lockAmount >= _amount, ERROR_NOT_ENOUGH_LOCK);\n\n        // update lock amount\n        // No need for SafeMath: checked just above\n        uint256 newAmount = lockAmount - _amount;\n        lock_.amount = newAmount;\n\n        // update total\n        account.totalLocked = account.totalLocked.sub(_amount);\n\n        emit LockAmountChanged(_user, _lockManager, newAmount);\n    }\n\n    function _transfer(address _from, address _to, uint256 _amount) internal {\n        // transferring 0 staked tokens is invalid\n        require(_amount > 0, ERROR_AMOUNT_ZERO);\n\n        // update stakes\n        _modifyStakeBalance(_from, _amount, false);\n        _modifyStakeBalance(_to, _amount, true);\n\n        emit StakeTransferred(_from, _to, _amount);\n    }\n\n    /**\n     * @dev This is similar to a `_transfer()` followed by a `_unstake()`, but optimized to avoid spurious SSTOREs on modifying _to's checkpointed balance\n     */\n    function _transferAndUnstake(address _from, address _to, uint256 _amount) internal {\n        // transferring 0 staked tokens is invalid\n        require(_amount > 0, ERROR_AMOUNT_ZERO);\n\n        // update stake\n        uint256 newStake = _modifyStakeBalance(_from, _amount, false);\n\n        // checkpoint total supply\n        _modifyTotalStaked(_amount, false);\n\n        emit Unstaked(_from, _amount, newStake, new bytes(0));\n\n        // transfer tokens\n        require(token.safeTransfer(_to, _amount), ERROR_TOKEN_TRANSFER);\n    }\n\n    function _totalStakedFor(address _user) internal view returns (uint256) {\n        // we assume it's not possible to stake in the future\n        return accounts[_user].stakedHistory.getLast();\n    }\n\n    function _totalStaked() internal view returns (uint256) {\n        // we assume it's not possible to stake in the future\n        return totalStakedHistory.getLast();\n    }\n\n    function _unlockedBalanceOf(address _user) internal view returns (uint256) {\n        return _totalStakedFor(_user).sub(_lockedBalanceOf(_user));\n    }\n\n    function _lockedBalanceOf(address _user) internal view returns (uint256) {\n        return accounts[_user].totalLocked;\n    }\n\n    /**\n     * @dev If calling this from a state modifying function trying to unlock tokens, make sure the first parameter is `msg.sender`.\n     * @param _sender Address that would try to unlock tokens\n     * @param _user Owner of lock\n     * @param _lockManager Lock manager\n     * @param _amount Amount of locked tokens to unlock. If zero, the full locked amount.\n     * @return Whether sender is allowed to unlock tokens from the given lock\n     */\n    function _canUnlockUnsafe(address _sender, address _user, address _lockManager, uint256 _amount) internal view returns (bool) {\n        Lock storage lock_ = accounts[_user].locks[_lockManager];\n        require(lock_.allowance > 0, ERROR_LOCK_DOES_NOT_EXIST);\n        require(lock_.amount >= _amount, ERROR_NOT_ENOUGH_LOCK);\n\n        uint256 amount = _amount == 0 ? lock_.amount : _amount;\n\n        // If the sender is the lock manager, unlocking is allowed\n        if (_sender == _lockManager) {\n            return true;\n        }\n\n        // If the sender is neither the lock manager nor the owner, unlocking is not allowed\n        if (_sender != _user) {\n            return false;\n        }\n\n        // The sender must be the user\n        // Allow unlocking if the amount of locked tokens for the user has already been decreased to 0\n        if (amount == 0) {\n            return true;\n        }\n\n        // Otherwise, check whether the lock manager allows unlocking\n        return ILockManager(_lockManager).canUnlock(_user, amount);\n    }\n}\n"
    },
    "contracts/StakingFactory.sol": {
      "content": "pragma solidity ^0.5.17;\n\nimport \"./standards/IERC20.sol\";\n\nimport \"./Staking.sol\";\n\n\ncontract StakingFactory {\n    mapping (address => address) internal instances;\n\n    event NewStaking(address indexed instance, address indexed token);\n\n    function existsInstance(IERC20 _token) external view returns (bool) {\n        return address(getInstance(_token)) != address(0);\n    }\n\n    function getOrCreateInstance(IERC20 _token) external returns (Staking) {\n        Staking instance = getInstance(_token);\n        return address(instance) != address(0) ? instance : _createInstance(_token);\n    }\n\n    function getInstance(IERC20 _token) public view returns (Staking) {\n        return Staking(instances[address(_token)]);\n    }\n\n    function _createInstance(IERC20 _token) internal returns (Staking) {\n        Staking instance = new Staking(_token);\n        address tokenAddress = address(_token);\n        address instanceAddress = address(instance);\n        instances[tokenAddress] = instanceAddress;\n        emit NewStaking(instanceAddress, tokenAddress);\n        return instance;\n    }\n}\n"
    },
    "contracts/standards/IApproveAndCallFallBack.sol": {
      "content": "// See MiniMe token (https://github.com/Giveth/minime/blob/master/contracts/MiniMeToken.sol)\n\npragma solidity ^0.5.17;\n\n\ninterface IApproveAndCallFallBack {\n    function receiveApproval(\n        address from,\n        uint256 _amount,\n        address _token,\n        bytes calldata _data\n    ) external;\n}\n"
    },
    "contracts/standards/IERC20.sol": {
      "content": "// Brought from https://github.com/aragon/aragonOS/blob/v4.3.0/contracts/lib/token/ERC20.sol\n// Adapted to use pragma ^0.5.17 and satisfy our linter rules\n\npragma solidity ^0.5.17;\n\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address _who) external view returns (uint256);\n\n    function allowance(address _owner, address _spender) external view returns (uint256);\n\n    function transfer(address _to, uint256 _value) external returns (bool);\n\n    function approve(address _spender, uint256 _value) external returns (bool);\n\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\n\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 value\n    );\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n"
    },
    "contracts/standards/IERC900.sol": {
      "content": "pragma solidity ^0.5.17;\n\n\n// Interface for ERC900: https://eips.ethereum.org/EIPS/eip-900\ninterface IERC900 {\n    event Staked(address indexed user, uint256 amount, uint256 total, bytes data);\n    event Unstaked(address indexed user, uint256 amount, uint256 total, bytes data);\n\n    /**\n     * @dev Stake a certain amount of tokens\n     * @param _amount Amount of tokens to be staked\n     * @param _data Optional data that can be used to add signalling information in more complex staking applications\n     */\n    function stake(uint256 _amount, bytes calldata _data) external;\n\n    /**\n     * @dev Stake a certain amount of tokens to another address\n     * @param _user Address to stake tokens to\n     * @param _amount Amount of tokens to be staked\n     * @param _data Optional data that can be used to add signalling information in more complex staking applications\n     */\n    function stakeFor(address _user, uint256 _amount, bytes calldata _data) external;\n\n    /**\n     * @dev Unstake a certain amount of tokens\n     * @param _amount Amount of tokens to be unstaked\n     * @param _data Optional data that can be used to add signalling information in more complex staking applications\n     */\n    function unstake(uint256 _amount, bytes calldata _data) external;\n\n    /**\n     * @dev Tell the current total amount of tokens staked for an address\n     * @param _addr Address to query\n     * @return Current total amount of tokens staked for the address\n     */\n    function totalStakedFor(address _addr) external view returns (uint256);\n\n    /**\n     * @dev Tell the current total amount of tokens staked from all addresses\n     * @return Current total amount of tokens staked from all addresses\n     */\n    function totalStaked() external view returns (uint256);\n\n    /**\n     * @dev Tell the address of the staking token\n     * @return Address of the staking token\n     */\n    function token() external view returns (address);\n\n    /*\n     * @dev Tell if the optional history functions are implemented\n     * @return True if the optional history functions are implemented\n     */\n    function supportsHistory() external pure returns (bool);\n}\n"
    },
    "contracts/standards/IERC900History.sol": {
      "content": "pragma solidity ^0.5.17;\n\n\n// Interface for ERC900: https://eips.ethereum.org/EIPS/eip-900, optional History methods\ninterface IERC900History {\n    /**\n     * @dev Tell last time a user modified their staked balance\n     * @param _user Address to query\n     * @return Last block number when address's balance was modified\n     */\n    function lastStakedFor(address _user) external view returns (uint256);\n\n    /**\n     * @dev Tell the total amount of tokens staked for an address at a given block number\n     * @param _user Address to query\n     * @param _blockNumber Block number\n     * @return Total amount of tokens staked for the address at the given block number\n     */\n    function totalStakedForAt(address _user, uint256 _blockNumber) external view returns (uint256);\n\n    /**\n     * @dev Tell the total amount of tokens staked from all addresses at a given block number\n     * @param _blockNumber Block number\n     * @return Total amount of tokens staked from all addresses at the given block number\n     */\n    function totalStakedAt(uint256 _blockNumber) external view returns (uint256);\n}\n"
    },
    "contracts/test/lib/EchidnaStaking.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport \"../../Staking.sol\";\nimport \"../../lib/os/SafeMath.sol\";\nimport \"../mocks/NoApproveTokenMock.sol\";\n\n\ncontract EchidnaStaking is Staking {\n    using SafeMath for uint256;\n\n    constructor() public {\n        token = IERC20(new NoApproveTokenMock(msg.sender, 10 ** 24));\n    }\n\n    // check that staked amount for an account is always >= total locked\n    function echidna_account_stake_locks() external view returns (bool) {\n        address _account = msg.sender;\n        Account storage account = accounts[_account];\n\n        if (_totalStakedFor(_account) < account.totalLocked) {\n            return false;\n        }\n\n        return true;\n    }\n\n    // TODO: delete. Fake test to check that previous echidna test works\n    function echidna_account_stake_locks_fake() external view returns (bool) {\n        address _account = msg.sender;\n        Account storage account = accounts[_account];\n\n        if (_totalStakedFor(_account) > account.totalLocked) {\n            return false;\n        }\n\n        return true;\n    }\n\n\n    // check that Checkpointing history arrays are ordered\n    function echidna_global_history_is_ordered() external view returns (bool) {\n        for (uint256 i = 1; i < totalStakedHistory.history.length; i++) {\n            if (totalStakedHistory.history[i].time <= totalStakedHistory.history[i - 1].time) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    function echidna_user_history_is_ordered() external view returns (bool) {\n        address account = msg.sender;\n        for (uint256 i = 1; i < accounts[account].stakedHistory.history.length; i++) {\n            if (accounts[account].stakedHistory.history[i].time <= accounts[account].stakedHistory.history[i - 1].time) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    // total staked matches less or equal than token balance\n    function echidna_total_staked_is_balance() external view returns (bool) {\n        if (_totalStaked() <= token.balanceOf(address(this))) {\n            return true;\n        }\n\n        return false;\n    }\n\n    function echidna_staked_ge_unlocked() external view returns (bool) {\n        if (_unlockedBalanceOf(msg.sender) > _totalStakedFor(msg.sender)) {\n            return false;\n        }\n\n        return true;\n    }\n\n    function echidna_staked_ge_locked() external view returns (bool) {\n        if (_lockedBalanceOf(msg.sender) > _totalStakedFor(msg.sender)) {\n            return false;\n        }\n\n        return true;\n    }\n\n    // sum of all account stakes should be equal to total staked and to staking token balance of staking contract, but it's hard to compute as accounts is a mapping\n}\n"
    },
    "contracts/test/mocks/BadTokenMock.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport \"../../standards/IERC20.sol\";\nimport \"../../lib/os/SafeMath.sol\";\n\n\n/**\n * @title Bad ERC20 token mock\n *\n * @dev Transfer function always returns false!\n */\ncontract BadTokenMock is IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private balances;\n\n    mapping (address => mapping (address => uint256)) private allowed;\n\n    uint256 private totalSupply_;\n\n    constructor(address initialAccount, uint256 initialBalance) public {\n        balances[initialAccount] = initialBalance;\n        totalSupply_ = initialBalance;\n    }\n\n    function mint (address account, uint256 amount) public {\n        balances[account] = balances[account].add(amount);\n        totalSupply_ = totalSupply_.add(amount);\n    }\n\n    /**\n     * @dev Total number of tokens in existence\n     */\n    function totalSupply() public view returns (uint256) {\n        return totalSupply_;\n    }\n\n    /**\n     * @dev Gets the balance of the specified address.\n     * @param _owner The address to query the the balance of.\n     * @return An uint256 representing the amount owned by the passed address.\n     */\n    function balanceOf(address _owner) public view returns (uint256) {\n        return balances[_owner];\n    }\n\n    /**\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\n     * @param _owner address The address which owns the funds.\n     * @param _spender address The address which will spend the funds.\n     * @return A uint256 specifying the amount of tokens still available for the spender.\n     */\n    function allowance(\n        address _owner,\n        address _spender\n    )\n        public\n        view\n        returns (uint256)\n    {\n        return allowed[_owner][_spender];\n    }\n\n    /**\n     * @dev Transfer token for a specified address\n     * @param _to The address to transfer to.\n     * @param _value The amount to be transferred.\n     */\n    function transfer(address _to, uint256 _value) public returns (bool) {\n        require(_value <= balances[msg.sender]);\n        require(_to != address(0));\n\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        emit Transfer(msg.sender, _to, _value);\n        return false; // <--- Bad Token!!\n    }\n\n    /**\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     * @param _spender The address which will spend the funds.\n     * @param _value The amount of tokens to be spent.\n     */\n    function approve(address _spender, uint256 _value) public returns (bool) {\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    /**\n     * @dev Transfer tokens from one address to another\n     * @param _from address The address which you want to send tokens from\n     * @param _to address The address which you want to transfer to\n     * @param _value uint256 the amount of tokens to be transferred\n     */\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    )\n        public\n        returns (bool)\n    {\n        require(_value <= balances[_from]);\n        require(_value <= allowed[_from][msg.sender]);\n        require(_to != address(0));\n\n        balances[_from] = balances[_from].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    /**\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\n     * approve should be called when allowed[_spender] == 0. To increment\n     * allowed value is better to use this function to avoid 2 calls (and wait until\n     * the first transaction is mined)\n     * From MonolithDAO Token.sol\n     * @param _spender The address which will spend the funds.\n     * @param _addedValue The amount of tokens to increase the allowance by.\n     */\n    function increaseApproval(\n        address _spender,\n        uint256 _addedValue\n    )\n        public\n        returns (bool)\n    {\n        allowed[msg.sender][_spender] = (\n            allowed[msg.sender][_spender].add(_addedValue));\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n    /**\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\n     * approve should be called when allowed[_spender] == 0. To decrement\n     * allowed value is better to use this function to avoid 2 calls (and wait until\n     * the first transaction is mined)\n     * From MonolithDAO Token.sol\n     * @param _spender The address which will spend the funds.\n     * @param _subtractedValue The amount of tokens to decrease the allowance by.\n     */\n    function decreaseApproval(\n        address _spender,\n        uint256 _subtractedValue\n    )\n        public\n        returns (bool)\n    {\n        uint256 oldValue = allowed[msg.sender][_spender];\n        if (_subtractedValue >= oldValue) {\n            allowed[msg.sender][_spender] = 0;\n        } else {\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n        }\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n    /**\n     * @dev Internal function that mints an amount of the token and assigns it to\n     * an account. This encapsulates the modification of balances such that the\n     * proper events are emitted.\n     * @param _account The account that will receive the created tokens.\n     * @param _amount The amount that will be created.\n     */\n    function _mint(address _account, uint256 _amount) internal {\n        require(_account != address(0));\n        totalSupply_ = totalSupply_.add(_amount);\n        balances[_account] = balances[_account].add(_amount);\n        emit Transfer(address(0), _account, _amount);\n    }\n\n    /**\n     * @dev Internal function that burns an amount of the token of a given\n     * account.\n     * @param _account The account whose tokens will be burnt.\n     * @param _amount The amount that will be burnt.\n     */\n    function _burn(address _account, uint256 _amount) internal {\n        require(_account != address(0));\n        require(_amount <= balances[_account]);\n\n        totalSupply_ = totalSupply_.sub(_amount);\n        balances[_account] = balances[_account].sub(_amount);\n        emit Transfer(_account, address(0), _amount);\n    }\n\n    /**\n     * @dev Internal function that burns an amount of the token of a given\n     * account, deducting from the sender's allowance for said account. Uses the\n     * internal _burn function.\n     * @param _account The account whose tokens will be burnt.\n     * @param _amount The amount that will be burnt.\n     */\n    function _burnFrom(address _account, uint256 _amount) internal {\n        require(_amount <= allowed[_account][msg.sender]);\n\n        // Should https://github.com/OpenZeppelin/zeppelin-solidity/issues/707 be accepted,\n        // this function needs to emit an event with the updated approval.\n        allowed[_account][msg.sender] = allowed[_account][msg.sender].sub(_amount);\n        _burn(_account, _amount);\n    }\n}\n"
    },
    "contracts/test/mocks/CheckpointingMock.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport \"../../lib/Checkpointing.sol\";\n\n\ncontract CheckpointingMock {\n    using Checkpointing for Checkpointing.History;\n\n    Checkpointing.History history;\n\n    function add(uint64 value, uint256 time) public {\n        history.add(value, time);\n    }\n\n    function getLast() public view returns (uint256) {\n        return history.getLast();\n    }\n\n    function get(uint64 time) public view returns (uint256) {\n        return history.get(time);\n    }\n\n    function getHistorySize() public view returns (uint256) {\n        return history.history.length;\n    }\n\n    function lastUpdate() public view returns (uint256) {\n        return history.lastUpdate();\n    }\n}\n"
    },
    "contracts/test/mocks/LockManagerMock.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport \"../../locking/ILockManager.sol\";\nimport \"../../Staking.sol\";\n\n\ncontract LockManagerMock is ILockManager {\n    bool result;\n\n    function lock(Staking _staking, address _user, uint256 _amount) external {\n        _staking.lock(_user, _amount);\n    }\n\n    function slash(Staking _staking, address _from, address _to, uint256 _amount) external {\n        _staking.slash(_from, _to, _amount);\n    }\n\n    function slashAndUnstake(Staking _staking, address _from, address _to, uint256 _amount) external {\n        _staking.slashAndUnstake(_from, _to, _amount);\n    }\n\n    function unlock(Staking _staking, address _account, uint256 _amount) external {\n        _staking.unlock(_account, address(this), _amount);\n    }\n\n    function unlockAndRemoveManager(Staking _staking, address _account) external {\n        _staking.unlockAndRemoveManager(_account, address(this));\n    }\n\n    function canUnlock(address, uint256) external view returns (bool) {\n        return result;\n    }\n\n    function setResult(bool _result) public {\n        result = _result;\n    }\n\n    function unlockAndRemoveManager(Staking _staking, address _account, address _manager) public {\n        _staking.unlockAndRemoveManager(_account, _manager);\n    }\n}\n"
    },
    "contracts/test/mocks/NoApproveTokenMock.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport \"../../standards/IERC20.sol\";\nimport \"../../lib/os/SafeMath.sol\";\n\n\n/**\n * @title Bad ERC20 token mock\n *\n * @dev No need to approve in order to transfer from\n */\ncontract NoApproveTokenMock is IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private balances;\n\n    mapping (address => mapping (address => uint256)) private allowed;\n\n    uint256 private totalSupply_;\n\n    constructor(address initialAccount, uint256 initialBalance) public {\n        balances[initialAccount] = initialBalance;\n        totalSupply_ = initialBalance;\n    }\n\n    function mint (address account, uint256 amount) public {\n        balances[account] = balances[account].add(amount);\n        totalSupply_ = totalSupply_.add(amount);\n    }\n\n    /**\n     * @dev Total number of tokens in existence\n     */\n    function totalSupply() public view returns (uint256) {\n        return totalSupply_;\n    }\n\n    /**\n     * @dev Gets the balance of the specified address.\n     * @param _owner The address to query the the balance of.\n     * @return An uint256 representing the amount owned by the passed address.\n     */\n    function balanceOf(address _owner) public view returns (uint256) {\n        return balances[_owner];\n    }\n\n    /**\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\n     * @param _owner address The address which owns the funds.\n     * @param _spender address The address which will spend the funds.\n     * @return A uint256 specifying the amount of tokens still available for the spender.\n     */\n    function allowance(\n        address _owner,\n        address _spender\n    )\n        public\n        view\n        returns (uint256)\n    {\n        return allowed[_owner][_spender];\n    }\n\n    /**\n     * @dev Transfer token for a specified address\n     * @param _to The address to transfer to.\n     * @param _value The amount to be transferred.\n     */\n    function transfer(address _to, uint256 _value) public returns (bool) {\n        require(_value <= balances[msg.sender]);\n        require(_to != address(0));\n\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    /**\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     * @param _spender The address which will spend the funds.\n     * @param _value The amount of tokens to be spent.\n     */\n    function approve(address _spender, uint256 _value) public returns (bool) {\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    /**\n     * @dev Transfer tokens from one address to another\n     * @param _from address The address which you want to send tokens from\n     * @param _to address The address which you want to transfer to\n     * @param _value uint256 the amount of tokens to be transferred\n     */\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    )\n        public\n        returns (bool)\n    {\n        require(_value <= balances[_from]);\n        // Bad token!\n        // require(_value <= allowed[_from][msg.sender]);\n        require(_to != address(0));\n\n        balances[_from] = balances[_from].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        //allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    /**\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\n     * approve should be called when allowed[_spender] == 0. To increment\n     * allowed value is better to use this function to avoid 2 calls (and wait until\n     * the first transaction is mined)\n     * From MonolithDAO Token.sol\n     * @param _spender The address which will spend the funds.\n     * @param _addedValue The amount of tokens to increase the allowance by.\n     */\n    function increaseApproval(\n        address _spender,\n        uint256 _addedValue\n    )\n        public\n        returns (bool)\n    {\n        allowed[msg.sender][_spender] = (\n            allowed[msg.sender][_spender].add(_addedValue));\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n    /**\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\n     * approve should be called when allowed[_spender] == 0. To decrement\n     * allowed value is better to use this function to avoid 2 calls (and wait until\n     * the first transaction is mined)\n     * From MonolithDAO Token.sol\n     * @param _spender The address which will spend the funds.\n     * @param _subtractedValue The amount of tokens to decrease the allowance by.\n     */\n    function decreaseApproval(\n        address _spender,\n        uint256 _subtractedValue\n    )\n        public\n        returns (bool)\n    {\n        uint256 oldValue = allowed[msg.sender][_spender];\n        if (_subtractedValue >= oldValue) {\n            allowed[msg.sender][_spender] = 0;\n        } else {\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n        }\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n    /**\n     * @dev Internal function that mints an amount of the token and assigns it to\n     * an account. This encapsulates the modification of balances such that the\n     * proper events are emitted.\n     * @param _account The account that will receive the created tokens.\n     * @param _amount The amount that will be created.\n     */\n    function _mint(address _account, uint256 _amount) internal {\n        require(_account != address(0));\n        totalSupply_ = totalSupply_.add(_amount);\n        balances[_account] = balances[_account].add(_amount);\n        emit Transfer(address(0), _account, _amount);\n    }\n\n    /**\n     * @dev Internal function that burns an amount of the token of a given\n     * account.\n     * @param _account The account whose tokens will be burnt.\n     * @param _amount The amount that will be burnt.\n     */\n    function _burn(address _account, uint256 _amount) internal {\n        require(_account != address(0));\n        require(_amount <= balances[_account]);\n\n        totalSupply_ = totalSupply_.sub(_amount);\n        balances[_account] = balances[_account].sub(_amount);\n        emit Transfer(_account, address(0), _amount);\n    }\n\n    /**\n     * @dev Internal function that burns an amount of the token of a given\n     * account, deducting from the sender's allowance for said account. Uses the\n     * internal _burn function.\n     * @param _account The account whose tokens will be burnt.\n     * @param _amount The amount that will be burnt.\n     */\n    function _burnFrom(address _account, uint256 _amount) internal {\n        require(_amount <= allowed[_account][msg.sender]);\n\n        // Should https://github.com/OpenZeppelin/zeppelin-solidity/issues/707 be accepted,\n        // this function needs to emit an event with the updated approval.\n        allowed[_account][msg.sender] = allowed[_account][msg.sender].sub(_amount);\n        _burn(_account, _amount);\n    }\n}\n"
    },
    "contracts/test/mocks/StakingMock.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport \"../../Staking.sol\";\nimport \"./TimeHelpersMock.sol\";\n\n\ncontract StakingMock is Staking, TimeHelpersMock {\n    constructor(IERC20 _stakingToken) Staking(_stakingToken) public {}\n\n    function setBlockNumber(uint64 _mockedBlockNumber) public {\n        mockedBlockNumber = _mockedBlockNumber;\n    }\n}\n"
    },
    "contracts/test/mocks/StandardTokenMock.sol": {
      "content": "// Copied from https://github.com/OpenZeppelin/openzeppelin-solidity/blob/a9f910d34f0ab33a1ae5e714f69f9596a02b4d91/contracts/token/ERC20/StandardToken.sol\n\npragma solidity 0.5.17;\n\nimport \"../../standards/IERC20.sol\";\nimport \"../../lib/os/SafeMath.sol\";\n\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\n */\ncontract StandardTokenMock is IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private balances;\n\n    mapping (address => mapping (address => uint256)) private allowed;\n\n    uint256 private totalSupply_;\n\n    constructor(address initialAccount, uint256 initialBalance) public {\n        balances[initialAccount] = initialBalance;\n        totalSupply_ = initialBalance;\n    }\n\n    function mint (address account, uint256 amount) public {\n        balances[account] = balances[account].add(amount);\n        totalSupply_ = totalSupply_.add(amount);\n    }\n\n    /**\n     * @dev Total number of tokens in existence\n     */\n    function totalSupply() public view returns (uint256) {\n        return totalSupply_;\n    }\n\n    /**\n     * @dev Gets the balance of the specified address.\n     * @param _owner The address to query the the balance of.\n     * @return An uint256 representing the amount owned by the passed address.\n     */\n    function balanceOf(address _owner) public view returns (uint256) {\n        return balances[_owner];\n    }\n\n    /**\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\n     * @param _owner address The address which owns the funds.\n     * @param _spender address The address which will spend the funds.\n     * @return A uint256 specifying the amount of tokens still available for the spender.\n     */\n    function allowance(\n        address _owner,\n        address _spender\n    )\n        public\n        view\n        returns (uint256)\n    {\n        return allowed[_owner][_spender];\n    }\n\n    /**\n     * @dev Transfer token for a specified address\n     * @param _to The address to transfer to.\n     * @param _value The amount to be transferred.\n     */\n    function transfer(address _to, uint256 _value) public returns (bool) {\n        require(_value <= balances[msg.sender]);\n        require(_to != address(0));\n\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    /**\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     * @param _spender The address which will spend the funds.\n     * @param _value The amount of tokens to be spent.\n     */\n    function approve(address _spender, uint256 _value) public returns (bool) {\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    /**\n     * @dev Transfer tokens from one address to another\n     * @param _from address The address which you want to send tokens from\n     * @param _to address The address which you want to transfer to\n     * @param _value uint256 the amount of tokens to be transferred\n     */\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    )\n        public\n        returns (bool)\n    {\n        require(_value <= balances[_from]);\n        require(_value <= allowed[_from][msg.sender]);\n        require(_to != address(0));\n\n        balances[_from] = balances[_from].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    /**\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\n     * approve should be called when allowed[_spender] == 0. To increment\n     * allowed value is better to use this function to avoid 2 calls (and wait until\n     * the first transaction is mined)\n     * From MonolithDAO Token.sol\n     * @param _spender The address which will spend the funds.\n     * @param _addedValue The amount of tokens to increase the allowance by.\n     */\n    function increaseApproval(\n        address _spender,\n        uint256 _addedValue\n    )\n        public\n        returns (bool)\n    {\n        allowed[msg.sender][_spender] = (\n            allowed[msg.sender][_spender].add(_addedValue));\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n    /**\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\n     * approve should be called when allowed[_spender] == 0. To decrement\n     * allowed value is better to use this function to avoid 2 calls (and wait until\n     * the first transaction is mined)\n     * From MonolithDAO Token.sol\n     * @param _spender The address which will spend the funds.\n     * @param _subtractedValue The amount of tokens to decrease the allowance by.\n     */\n    function decreaseApproval(\n        address _spender,\n        uint256 _subtractedValue\n    )\n        public\n        returns (bool)\n    {\n        uint256 oldValue = allowed[msg.sender][_spender];\n        if (_subtractedValue >= oldValue) {\n            allowed[msg.sender][_spender] = 0;\n        } else {\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n        }\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n    /**\n     * @dev Internal function that mints an amount of the token and assigns it to\n     * an account. This encapsulates the modification of balances such that the\n     * proper events are emitted.\n     * @param _account The account that will receive the created tokens.\n     * @param _amount The amount that will be created.\n     */\n    function _mint(address _account, uint256 _amount) internal {\n        require(_account != address(0));\n        totalSupply_ = totalSupply_.add(_amount);\n        balances[_account] = balances[_account].add(_amount);\n        emit Transfer(address(0), _account, _amount);\n    }\n\n    /**\n     * @dev Internal function that burns an amount of the token of a given\n     * account.\n     * @param _account The account whose tokens will be burnt.\n     * @param _amount The amount that will be burnt.\n     */\n    function _burn(address _account, uint256 _amount) internal {\n        require(_account != address(0));\n        require(_amount <= balances[_account]);\n\n        totalSupply_ = totalSupply_.sub(_amount);\n        balances[_account] = balances[_account].sub(_amount);\n        emit Transfer(_account, address(0), _amount);\n    }\n\n    /**\n     * @dev Internal function that burns an amount of the token of a given\n     * account, deducting from the sender's allowance for said account. Uses the\n     * internal _burn function.\n     * @param _account The account whose tokens will be burnt.\n     * @param _amount The amount that will be burnt.\n     */\n    function _burnFrom(address _account, uint256 _amount) internal {\n        require(_amount <= allowed[_account][msg.sender]);\n\n        // Should https://github.com/OpenZeppelin/zeppelin-solidity/issues/707 be accepted,\n        // this function needs to emit an event with the updated approval.\n        allowed[_account][msg.sender] = allowed[_account][msg.sender].sub(_amount);\n        _burn(_account, _amount);\n    }\n}\n"
    },
    "contracts/test/mocks/TimeHelpersMock.sol": {
      "content": "pragma solidity ^0.5.17;\n\nimport \"../../lib/os/TimeHelpers.sol\";\nimport \"../..//lib/os/SafeMath.sol\";\nimport \"../..//lib/os/SafeMath64.sol\";\n\n\ncontract TimeHelpersMock is TimeHelpers {\n    using SafeMath for uint256;\n    using SafeMath64 for uint64;\n\n    uint256 public mockedTimestamp;\n    uint256 public mockedBlockNumber;\n\n    /**\n    * @dev Sets a mocked timestamp value, used only for testing purposes\n    */\n    function mockSetTimestamp(uint256 _timestamp) external {\n        mockedTimestamp = _timestamp;\n    }\n\n    /**\n    * @dev Increases the mocked timestamp value, used only for testing purposes\n    */\n    function mockIncreaseTime(uint256 _seconds) external {\n        if (mockedTimestamp != 0) mockedTimestamp = mockedTimestamp.add(_seconds);\n        else mockedTimestamp = block.timestamp.add(_seconds);\n    }\n\n    /**\n    * @dev Decreases the mocked timestamp value, used only for testing purposes\n    */\n    function mockDecreaseTime(uint256 _seconds) external {\n        if (mockedTimestamp != 0) mockedTimestamp = mockedTimestamp.sub(_seconds);\n        else mockedTimestamp = block.timestamp.sub(_seconds);\n    }\n\n    /**\n    * @dev Advances the mocked block number value, used only for testing purposes\n    */\n    function mockAdvanceBlocks(uint256 _number) external {\n        if (mockedBlockNumber != 0) mockedBlockNumber = mockedBlockNumber.add(_number);\n        else mockedBlockNumber = block.number.add(_number);\n    }\n\n    /**\n    * @dev Returns the mocked timestamp value\n    */\n    function getTimestampPublic() external view returns (uint64) {\n        return getTimestamp64();\n    }\n\n    /**\n    * @dev Returns the mocked block number value\n    */\n    function getBlockNumberPublic() external view returns (uint256) {\n        return getBlockNumber();\n    }\n\n    /**\n    * @dev Returns the mocked timestamp if it was set, or current `block.timestamp`\n    */\n    function getTimestamp() internal view returns (uint256) {\n        if (mockedTimestamp != 0) return mockedTimestamp;\n        return super.getTimestamp();\n    }\n\n    /**\n    * @dev Returns the mocked block number if it was set, or current `block.number`\n    */\n    function getBlockNumber() internal view returns (uint256) {\n        if (mockedBlockNumber != 0) return mockedBlockNumber;\n        return super.getBlockNumber();\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 10000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}